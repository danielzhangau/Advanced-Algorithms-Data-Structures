# Algorithms and data structure

A number of general design paradigms, such as divide-and-conquer, play an important role in the development of algorithms. Familiarity with these paradigms can aid the programmer in the development of algorithms to solve new problems. 
It is not enough just to derive an algorithm that solves a problem. If the algorithm is inefficient, it may be useless in practice. One can better appreciate an algorithm if one can analyse its use of resources, such as memory and computing time. Such analyses provide the basis for comparison of different algorithms to solve the same problem.

## What is covered:
* ### Introduction and mathematical background: 
Time and space complexity: the desire for an implementation independent measure; worst-case and average-case complexity.
Evaluating efficiency: rate of growth, asymptotic time complexity; notation.
Iterative algorithms: analysis of "while" and "for" loops; summations.

* ### Divide and conquer algorithms and recurrences: 
Divide-and conquer: recursion; divide, conquer and combine.
Solving recurrences: substitution; iterating the recurrence to get a summation; recursion trees; master method.

* ### Graph algorithms - Directed and undirected graphs: 
vertex, edge, predecessor, successor, in-degree, out-degree, path, reachable, simple, cycle; weighted graphs.
Graph representations: adjacency list and matrix representations.
Graph algorithms: breadth-first search; depth-first search; topological sort.
Minimal spanning tree: generic form, greedy choice strategy.

* ### Dynamic programming: 
Optimal substructure; overlapping sub-problems; table of sub-problem solutions; memoization; order of evaluation; dynamic programming.

* ### Greedy algorithms: 
Greedy method: optimal substructure; greedy choice property; comparison of dynamic programming and greedy paradigms.

* ### Amortised analysis: 
Efficiency analysis in terms of sequences of operations; crude analysis; global analysis; the accounting method; the potential method.

* ### Complexity classes: 
Decision problems; tractable and intractable problems; Polynomial time; the class P; Polynomial time verification; the class NP; reducibility; NP-completeness. Traveling-salesman problem.

* ### Randomised algorithms: 
probabilistic analysis, randomised quicksort

## What I have learned:
1.	Analyse, compare, and contrast algorithms and data structures by evaluating their time and space complexity.
2.	Apply algorithm design paradigms to generate novel solutions.
3.	Design abstract solutions based on graph algorithms, dynamic programming, and greedy methods.
4.	Develop efficient implementations to abstract solutions.
5.	Perform amortised analysis of data structures and algorithms.
6	Explain the theory and relevance of theoretical complexity classes.
